# Выделение ребер на изображении с использованием оператора Собеля

- Студент: Четверикова Екатерина Евгеньевна, группа 3823Б1ПМоп3
- Технология: SEQ, MPI
- Вариант: 23


## 1. Введение

Операция свертки изображения с использованием фильтров (ядер) Собеля — это одна из фундаментальных процедур в компьютерном зрении и обработке графических данных. Эта операция лежит в основе вычислительных методов, направленных на обнаружение контуров объектов, вычисление направленных градиентов яркости и применяется во множестве других техник анализа изображений.

Основная цель данной работы — разработка и сравнение производительности последовательной и параллельной версий алгоритма свертки изображения при помощи операторов Собеля, предназначенного для детектирования границ.


## 2. Постановка задачи

Для заданного изображения (в оттенках серого), представленного в виде одномерного массива пикселей, необходимо применить оператор Собеля для выделения ребер.

**Вход:** структура `ImageData`, содержащая:
- `pixels` — одномерный массив пикселей изображения (int)
- `width` — ширина изображения
- `height` — высота изображения
- `channels` — количество каналов (1 для grayscale, 3 для RGB)

**Выход:** одномерный массив пикселей (int) с выделенными ребрами. Границы заполнены нулями.

**Ограничения:**
- Изображение задано в виде одномерного массива
- Загружать реальное изображение не требуется
- Результат должен быть в формате grayscale (один канал)

Оператор Собеля использует две матрицы свертки 3×3:
- **Gx** (горизонтальные границы): `[[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]`
- **Gy** (вертикальные границы): `[[-1, -2, -1], [0, 0, 0], [1, 2, 1]]`

Величина градиента вычисляется как: `G = sqrt(Gx**2 + Gy**2)`


## 3. Описание последовательного алгоритма 

Последовательный алгоритм применяет оператор Собеля ко всему изображению.
```cpp
int ConvSobel(const std::vector<int> &data, std::size_t idx, int width) {
  int gx = (kKernelSobelX[0][0] * data[idx - static_cast<std::size_t>(width) - 1]) +
           (kKernelSobelX[0][1] * data[idx - static_cast<std::size_t>(width)]) +
           (kKernelSobelX[0][2] * data[idx - static_cast<std::size_t>(width) + 1]) +

           (kKernelSobelX[1][0] * data[idx - 1]) + (kKernelSobelX[1][1] * data[idx]) +
           (kKernelSobelX[1][2] * data[idx + 1]) +

           (kKernelSobelX[2][0] * data[idx + static_cast<std::size_t>(width) - 1]) +
           (kKernelSobelX[2][1] * data[idx + static_cast<std::size_t>(width)]) +
           (kKernelSobelX[2][2] * data[idx + static_cast<std::size_t>(width) + 1]);

  int gy = (kKernelSobelY[0][0] * data[idx - static_cast<std::size_t>(width) - 1]) +
           (kKernelSobelY[0][1] * data[idx - static_cast<std::size_t>(width)]) +
           (kKernelSobelY[0][2] * data[idx - static_cast<std::size_t>(width) + 1]) +

           (kKernelSobelY[1][0] * data[idx - 1]) + (kKernelSobelY[1][1] * data[idx]) +
           (kKernelSobelY[1][2] * data[idx + 1]) +

           (kKernelSobelY[2][0] * data[idx + static_cast<std::size_t>(width) - 1]) +
           (kKernelSobelY[2][1] * data[idx + static_cast<std::size_t>(width)]) +
           (kKernelSobelY[2][2] * data[idx + static_cast<std::size_t>(width) + 1]);

  double magnitude = std::sqrt(static_cast<double>((gx * gx) + (gy * gy)));
  magnitude = std::min(255.0, std::max(0.0, magnitude));

  return static_cast<int>(std::round(magnitude));
}

std::vector<int> ApplySobelOperator(const std::vector<int> &image, int width, int height) {
  std::size_t result_size = static_cast<std::size_t>(width) * static_cast<std::size_t>(height);
  std::vector<int> result(result_size, 0);

  if (width < 3 || height < 3) {
    return result;
  }

  for (int row_index = 1; row_index < height - 1; ++row_index) {
    for (int col_index = 1; col_index < width - 1; ++col_index) {
      std::size_t idx =
          (static_cast<std::size_t>(row_index) * static_cast<std::size_t>(width)) + static_cast<std::size_t>(col_index);
      result[idx] = ConvSobel(image, idx, width);
    }
  }
  return result;
}


## 4. Схема распараллеливания

Основная идея заключается в разделении строк изображения между доступными процессами MPI.
Rank 0 вычисляет количество строк для каждого процесса. Если общее количество строк не делится нацело на количество процессов, остаток равномерно распределяется между первыми процессами. Размеры изображения (ширина и высота) рассылаются всем процессам. Для корректного вычисления свертки 3×3 на границах разделенных блоков каждому процессу необходима одна дополнительная строка сверху и одна снизу от соседних процессов. Для передачи фрагментов изображения используется MPI_Scatterv с учетом перекрытия. Это позволяет каждому процессу получить все необходимые данные для вычисления своей области за одну операцию. Каждый процесс вызывает функцию `ApplySobelOperator`, обрабатывая только "свои" чистые строки, используя соседние как вспомогательные. Сбор обработанных локальных результатов обратно на rank 0 процесс в единый вектор GetOutput().  `ApplySobelOperator` возвращает только обработанные строки, без вспомогательных сверху и снизу. 


## 6. Тестовая конфигурация

- Процессор: 2th Gen Intel(R) Core(TM) i7-1255U   2.60 GHz  (2 cores, 12 threads)
- Память: 16,0 ГБ DDR4
- Операционная система: Windows 10 Pro 22H2
- Реализация MPI: MS-MPI Version 10.1.12498.16
- Параметры запуска: `mpiexec -n <count>`
- Данные: матрица размерности 4000x4000


## 7. Экспериментальные результаты

Эксперименты проводились на локальной машине. Для оценки эффективности параллельного алгоритма тест проводился матрице 5000×5000 (в директории загружена другая матрица размерности 2000x2000 из-за ограничений на размер коммита).

| Mode        | Count | Time, s  | Speedup | Efficiency |
|-------------|-------|----------|---------|------------|
| mpi         | 1     | 0.351    | 1.00    | N/A        |
| mpi         | 2     | 0.254    | 0.72    | 36%        |
| mpi         | 4     | 0.232    | 0.66    | 33%        |
| mpi         | 6     | 0.270    | 0.76    | 38%        |

Наилучшая производительность достигнута при использовании 2 процессов, что соответствует числу ядер.


## 8. Заключение

В ходе работы реализован алгоритм параллельного выделение ребер на изображении с использованием оператора Собеля. Программа успешно проходит функциональные тесты, обеспечивая корректную обработку границ, согласованность данных между процессами.


## 9. Источники

MPI Standard: https://www.mpi-forum.org/docs/
OpenMPI Documentation: https://www.open-mpi.org/doc/